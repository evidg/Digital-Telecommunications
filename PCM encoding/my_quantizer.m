function [xq, centers, offside, step, space_p] = my_quantizer(x, N, min_value, max_value)
  
%Aνάλογα με τον αριθμό των bits ορίζω πόσες περιοχές κβάντισης θα έχω
y = 2^N;     
 
%Δημιουργώ το διάνυσμα xq που θα περιέχει το διάστημα που υπάρχει η κάθε
%τιμή του x ύστερα απο την κβάντιση και έχει μέγεθος 10.000 τιμές όσο
%δηλαδή και το μέγεθος του x.
xq = zeros(length(x), 1);  
 
%Yπολογίζω το βήμα κβάντισης του κβαντιστή το οποίο δίνεται απο την διαφορά
%της μεγαλύτερης και της μικρότερης τιμής προς το πλήθος των διαστημάτων
%κβάντισης όπως το έχουμε ορίσει παρακάτω.
step = (max_value - min_value)/y;
 
%Μετρητής που θα μας υπολογίζει πόσες τιμές είναι εκτός της περιοχής των 
%ορίων [0,4]. 
offside = 0;   
 
%Υπολογισμός της πιθανότητας κάθε διαστήματος σύμφωνα με τις τιμές του x.            
space_p = zeros(y, 1);  
 
%Υπολογισμός των σημειών κάθε διαστήματος κβάντισης, τα οποία θα έιναι 
%σε πλήθος όσο τα διαστήματα κβάντισης + 1.
points = zeros(y+1, 1); 
 
%Για κάθε ένα διάστημα κβάντισης θα υπάρχει και το κέντρο κβαντισής του.
centers = zeros(y, 1);
 
for i = 1:length(x)
%Εάν η περιοχή είναι μεγαλύτερη απο το 4 τότε αυξάνουμε την μεταβλητή
%offside κατά ένα και στην συνέχεια την ορίζουμε με 4 την μεγαλύτερη 
%τιμή ώστε να μπορέσει να κβαντιστεί.
 if x(i) > max_value
  offside = offside + 1;
  x(i) = max_value;
%Εάν η περιοχή είναι μικρότερη απο το 0 τότε αυξάνουμε την μεταβλητή
%offside κατά ένα όπως και πριν και ορίζουμε με 0 την μικρότερη αυτή  
%τιμή ώστε να μπορέσει να κβαντιστεί.
 elseif x(i) < min_value
        x(i) = min_value;
        offside = offside + 1;
    end
end
 
%Για να προσδιορίσω τις τιμές των σημείων κάθε διαστήματος θα ξεκινήσω απο 
%το min_value = 0 και κάθε φορά θα προσθέτω και ένα βήμα κβάντισης.
for j = 1:y+1
    points(j) = min_value + (j-1)*step;
end
 
for i = 1:length(x)
    for j = 1:y
        
%Επειδή θα πρέπει να επιστρέψουμε και το διάνυσμα xq που περιέχει για κάθε
%μια τιμή που κβαντίζεται το διάστημα που περιέχεται, για κάθε μια τιμή
%του x ελεγχω σε ποιο διάστημα ανήκει και στην συνέχεια αυξάνω την
%πιθανότητα εμφάνισης κατά ένα στο διάστημα αυτό ώστε να μπορούμε εύκολα
%στην συνέχεια να υπολογίσουμε ακριβώς μεσω του κλασσικού μαθηματικού
%τύπου την πιθανότητα του κάθε διαστήματος.
      if (x(i)>=points(j) && x(i)<=points(j+1))
         xq(i) = j;
         space_p(j) = space_p(j) + 1;
         break;
      end
   end
end
%Υπολογισμός πιθανότητα εμφάνισης του καθε διαστήματος 
space_p = space_p./length(x); 
 
%Για να μετρήσω τις τιμές των κέντρων κβάντισης κάθε διαστήματος θα 
%υπολογίσω το μέσο όρο των σημείων στα άκρα του διαστήματος που ανήκει.    
for i=1:y
   centers(i) = (points(i)+ points(i+1))/2;
end
